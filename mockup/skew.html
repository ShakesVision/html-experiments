<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>ShakeVision — 3D Tilt Studio (Perfect Export)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background: linear-gradient(145deg, #20102f, #0f0c29, #302b63, #24243e);
            background-size: 400% 400%;
            animation: bgMove 14s ease infinite;
        }

        @keyframes bgMove {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        .card {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.06));
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        #templateModal {
            backdrop-filter: blur(6px);
        }

        .btn-primary {
            background: linear-gradient(135deg, #7f5af0, #9775fa, #ff7ce5);
            color: white;
            font-weight: 600;
            transition: 0.2s;
        }

        .btn-primary:hover {
            filter: brightness(1.15);
            transform: translateY(-2px);
        }

        .slider-val {
            width: 60px;
        }

        #previewContainer {
            perspective-origin: center center;
            perspective-style: preserve-3d;
            perspective: 800px;
            /* default perspective */
        }

        #preview {
            transition: transform 0.15s ease-out;
            display: block;
            max-width: 100%;
            max-height: 600px;
            transform-style: preserve-3d;
            transform-origin: center center;
            border-radius: 8px;
            box-shadow:
                0 15px 40px rgba(127, 90, 240, 0.3),
                0 5px 12px rgba(255, 124, 229, 0.4);
        }
    </style>
</head>

<body class="min-h-screen text-white">

    <!-- Header -->
    <div class="flex justify-between items-center p-6">
        <h1
            class="text-3xl font-extrabold tracking-wide bg-gradient-to-r from-pink-400 to-purple-400 bg-clip-text text-transparent">
            ShakeVision 3D Tilt Studio
        </h1>

        <div class="space-x-3">
            <button id="saveTemplate" class="btn-primary px-4 py-2 rounded-lg">Save Template</button>
            <button id="loadTemplate" class="btn-primary px-4 py-2 rounded-lg">Load Template</button>
        </div>
    </div>

    <!-- Main Container -->
    <div class="max-w-6xl mx-auto card p-8 rounded-xl shadow-xl mt-4">

        <!-- Upload -->
        <div class="mb-6">
            <label class="font-semibold text-lg">Upload Image:</label>
            <input id="imageInput" type="file" accept="image/*" class="block mt-3 bg-white/10 px-4 py-2 rounded-lg" />
        </div>

        <div class="flex flex-col md:flex-row gap-8">

            <!-- Controls -->
            <div class="w-full md:w-1/3 space-y-6">

                <h2 class="text-xl font-bold mb-3">Transform Controls</h2>

                <div id="controls"></div>

                <!-- Download Button -->
                <button id="downloadBtn" class="btn-primary w-full py-3 rounded-xl mt-4 shadow-lg">
                    Download Transformed PNG
                </button>

            </div>

            <!-- Preview -->
            <div id="previewContainer" class="w-full md:w-2/3 flex justify-center items-center">
                <img id="preview" src="" alt="Preview Image" />
            </div>

        </div>
    </div>

    <!-- Attribution -->
    <div class="text-center mt-10 text-sm opacity-70">
        Built by <a href="#" class="text-pink-300 font-semibold">ShakeVision</a> — GitHub
    </div>

    <!-- Modal for Template Loading -->
    <div id="templateModal" class="hidden fixed inset-0 bg-black/50 flex justify-center items-center p-4">
        <div class="card p-8 rounded-xl max-w-md w-full shadow-2xl">
            <h2 class="text-xl font-bold mb-4">Saved Templates</h2>
            <div id="templateList" class="space-y-4 max-h-64 overflow-y-auto"></div>
            <button id="closeModal" class="btn-primary mt-6 w-full py-2 rounded-lg">Close</button>
        </div>
    </div>

    <script>
        // Control config
        const CONTROL_CONFIG = [
            { id: "perspective", label: "Perspective", min: 100, max: 2000, step: 1, value: 800 },
            { id: "rotateX", label: "Rotate X", min: -80, max: 80, step: 1, value: 0 },
            { id: "rotateY", label: "Rotate Y", min: -80, max: 80, step: 1, value: 0 },
            { id: "rotateZ", label: "Rotate Z", min: -180, max: 180, step: 1, value: 0 },
            { id: "skewX", label: "Skew X", min: -50, max: 50, step: 1, value: 0 },
            { id: "skewY", label: "Skew Y", min: -50, max: 50, step: 1, value: 0 },
            { id: "scale", label: "Scale", min: 0.5, max: 2, step: 0.01, value: 1 }
        ];

        const controlsDiv = document.getElementById("controls");
        const preview = document.getElementById("preview");
        const previewContainer = document.getElementById("previewContainer");
        const imageInput = document.getElementById("imageInput");

        // Generate controls UI
        controlsDiv.innerHTML = CONTROL_CONFIG.map(ctrl => `
    <div>
      <label class="block mb-1 font-semibold">${ctrl.label}</label>
      <div class="flex items-center gap-3">
        <input id="${ctrl.id}" type="range"
          min="${ctrl.min}" max="${ctrl.max}" value="${ctrl.value}" step="${ctrl.step}"
          class="w-full" />
        <input id="${ctrl.id}-val" type="number"
          class="text-black rounded-lg px-2 py-1 slider-val"
          min="${ctrl.min}" max="${ctrl.max}" step="${ctrl.step}" value="${ctrl.value}" />
      </div>
    </div>
  `).join("");

        // Update CSS transform on preview
        function updateTransform() {
            const v = id => document.getElementById(id).value;

            // Update container perspective dynamically
            previewContainer.style.perspective = `${v("perspective")}px`;

            preview.style.transform = `
      rotateX(${v("rotateX")}deg)
      rotateY(${v("rotateY")}deg)
      rotateZ(${v("rotateZ")}deg)
      skew(${v("skewX")}deg, ${v("skewY")}deg)
      scale(${v("scale")})
    `;
        }

        CONTROL_CONFIG.forEach(ctrl => {
            const slider = document.getElementById(ctrl.id);
            const input = document.getElementById(ctrl.id + "-val");

            slider.addEventListener("input", e => {
                input.value = e.target.value;
                updateTransform();
            });

            input.addEventListener("input", e => {
                slider.value = e.target.value;
                updateTransform();
            });
        });

        // Handle image upload
        imageInput.addEventListener("change", e => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => {
                preview.src = reader.result;
                updateTransform();
            };
            reader.readAsDataURL(file);
        });

        // Homography matrix solver for perspective warp:
        // From: https://github.com/moagrius/homography-js (MIT license, simplified)
        function computeHomography(src, dst) {
            // src and dst are arrays of 4 points [ [x,y], ... ]
            // Returns 3x3 matrix h as flat array (row-major)
            // Solve Ah = 0, 8 equations with 8 unknowns (h33=1)

            const A = [];
            for (let i = 0; i < 4; i++) {
                const [x, y] = src[i];
                const [u, v] = dst[i];
                A.push([-x, -y, -1, 0, 0, 0, u * x, u * y, u]);
                A.push([0, 0, 0, -x, -y, -1, v * x, v * y, v]);
            }

            // Solve system Ah=0 using SVD or gaussian elimination
            // We do simplified SVD substitute by numeric js approach

            // For simplicity we use numeric.js SVD here via CDN (lightweight)
        }

        // We will use numeric.js for matrix SVD
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>

    <script>
        // Complete homography calculation using numeric.js
        function computeHomography(src, dst) {
            const A = [];
            for (let i = 0; i < 4; i++) {
                const [x, y] = src[i];
                const [u, v] = dst[i];
                A.push([-x, -y, -1, 0, 0, 0, u * x, u * y, u]);
                A.push([0, 0, 0, -x, -y, -1, v * x, v * y, v]);
            }
            // A is 8x9 matrix, solve Ah=0 for h
            // SVD decomposition
            const svdRes = numeric.svd(A);
            // h is last column of V
            const h = svdRes.V[svdRes.V.length - 1];
            // Normalize
            for (let i = 0; i < h.length; i++) h[i] /= h[8];
            return h;
        }

        // Apply homography h to point (x,y)
        function applyH(h, x, y) {
            const denom = h[6] * x + h[7] * y + h[8];
            return [
                (h[0] * x + h[1] * y + h[2]) / denom,
                (h[3] * x + h[4] * y + h[5]) / denom,
            ];
        }

        // Get CSS transform matrix from rotateX/Y/Z + skew + scale
        // Then calculate final corner positions in screen space
        function getTransformedCorners(img, controls) {
            // We must replicate CSS 3D transform matrix calculation in JS
            // This is complicated, so let's use a library-free approximation:

            // 1. Get width/height of original image
            const w = img.naturalWidth;
            const h = img.naturalHeight;

            // 2. Calculate rotation matrices around X,Y,Z in radians
            const rx = controls.rotateX * Math.PI / 180;
            const ry = controls.rotateY * Math.PI / 180;
            const rz = controls.rotateZ * Math.PI / 180;

            const cosX = Math.cos(rx), sinX = Math.sin(rx);
            const cosY = Math.cos(ry), sinY = Math.sin(ry);
            const cosZ = Math.cos(rz), sinZ = Math.sin(rz);

            // Rotation matrices (3x3):
            // Rx
            const Rx = [
                [1, 0, 0],
                [0, cosX, -sinX],
                [0, sinX, cosX]
            ];
            // Ry
            const Ry = [
                [cosY, 0, sinY],
                [0, 1, 0],
                [-sinY, 0, cosY]
            ];
            // Rz
            const Rz = [
                [cosZ, -sinZ, 0],
                [sinZ, cosZ, 0],
                [0, 0, 1]
            ];

            // Compose R = Rz * Ry * Rx (order)
            function multiply3(a, b) {
                const r = [];
                for (let i = 0; i < 3; i++) {
                    r[i] = [];
                    for (let j = 0; j < 3; j++) {
                        r[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j] + a[i][2] * b[2][j];
                    }
                }
                return r;
            }

            const Ryx = multiply3(Ry, Rx);
            const R = multiply3(Rz, Ryx);

            // Skew matrices:
            // CSS skewX/skewY in degrees converted to radians
            const skewX = controls.skewX * Math.PI / 180;
            const skewY = controls.skewY * Math.PI / 180;

            // Skew matrix in 2D:
            // |1 tan(skewX) 0|
            // |tan(skewY) 1 0|
            // |0 0 1|
            // We will apply skew on the 2D projected points later.

            // Perspective distance from perspective control
            // Perspective is like distance from camera
            const perspective = controls.perspective;

            // Scale
            const scale = controls.scale;

            // Now calculate the 8 corners of the "box" but we only have a flat image,
            // so our 4 corners (x,y,z=0):
            // Top-left: (-w/2, -h/2, 0)
            // Top-right: (w/2, -h/2, 0)
            // Bottom-right: (w/2, h/2, 0)
            // Bottom-left: (-w/2, h/2, 0)

            const corners3D = [
                [-w / 2, -h / 2, 0],
                [w / 2, -h / 2, 0],
                [w / 2, h / 2, 0],
                [-w / 2, h / 2, 0],
            ];

            // Apply rotation matrix R on each corner
            const rotated = corners3D.map(([x, y, z]) => {
                return [
                    R[0][0] * x + R[0][1] * y + R[0][2] * z,
                    R[1][0] * x + R[1][1] * y + R[1][2] * z,
                    R[2][0] * x + R[2][1] * y + R[2][2] * z,
                ];
            });

            // Apply perspective projection (simple)
            // x' = (x * d) / (d + z)
            // y' = (y * d) / (d + z)
            // d = perspective
            // NOTE: Z is forward in CSS 3D space; positive Z means away from camera.

            const projected = rotated.map(([x, y, z]) => {
                const d = perspective;
                const px = (x * d) / (d + z);
                const py = (y * d) / (d + z);
                return [px, py];
            });

            // Apply skew
            // Skew matrix:
            // |1 tan(skewX)|
            // |tan(skewY) 1|
            const tanSkewX = Math.tan(skewX);
            const tanSkewY = Math.tan(skewY);

            const skewed = projected.map(([x, y]) => {
                return [
                    x + tanSkewX * y,
                    y + tanSkewY * x
                ];
            });

            // Apply scale
            const scaled = skewed.map(([x, y]) => [x * scale, y * scale]);

            // Translate back to image coordinate system with center at (w/2, h/2)
            // Because canvas coords start top-left
            const final = scaled.map(([x, y]) => [x + w / 2, y + h / 2]);

            return final;
        }

        // Draw image on canvas with 4-corner warp
        function drawImageWarped(ctx, img, corners) {
            // corners = array of 4 points in dest coords: tl, tr, br, bl
            // We'll use projective transform from unit square to corners.

            const w = img.naturalWidth;
            const h = img.naturalHeight;

            // Source corners in img coords
            const srcCorners = [
                [0, 0],
                [w, 0],
                [w, h],
                [0, h]
            ];

            // Compute homography H mapping srcCorners -> corners
            const H = computeHomography(srcCorners, corners);

            // Set canvas transform according to H
            // H is a 3x
            // Set canvas transform according to H
            // H is a 3x3 matrix stored as flat array:
            // [h0 h1 h2
            //  h3 h4 h5
            //  h6 h7 h8]

            // We want to map canvas unit square (source) to quadrilateral (dest)
            // Canvas 2D context transform supports only affine (6 params),
            // so we must do projective warp by manually transforming pixels.

            // We'll implement the classic approach:
            // Draw image in tiny chunks (scanlines) or
            // use a helper function to warp by decomposing H

            // To keep performance and code size reasonable,
            // we use a popular approach from https://stackoverflow.com/a/62812480
            // and from https://web.archive.org/web/20140205041146/http://www.html5rocks.com/en/tutorials/canvas/homography/

            // However, we don't have direct projective transform in canvas,
            // so we do a manual pixel mapping (slow but accurate for export).

            // Instead, we will draw the image into an offscreen canvas,
            // then sample pixel data and map them manually onto the output canvas.

            // But this is expensive; a better approach:
            // Approximate homography by dividing into triangles and use ctx.setTransform per triangle.

            // Let's do the triangle approach:

            // Triangles:
            // Tri 1: tl, tr, bl
            // Tri 2: tr, br, bl

            const [tl, tr, br, bl] = corners;

            // Draw function to draw image mapped on triangle from src to dest

            function drawTriangle(ctx, img, srcTri, dstTri) {
                // srcTri, dstTri: 3 points each [ [x,y], [x,y], [x,y] ]

                // Compute affine transform from srcTri -> dstTri (affine only)

                // Matrix form: M * [x y 1]^T = [x' y' 1]^T
                // Solve for M (2x3 matrix)

                const matrix = computeAffineTransform(srcTri, dstTri);

                ctx.save();
                ctx.beginPath();
                ctx.moveTo(dstTri[0][0], dstTri[0][1]);
                ctx.lineTo(dstTri[1][0], dstTri[1][1]);
                ctx.lineTo(dstTri[2][0], dstTri[2][1]);
                ctx.closePath();
                ctx.clip();

                // Set transform
                ctx.setTransform(
                    matrix.a, matrix.b,
                    matrix.c, matrix.d,
                    matrix.e, matrix.f
                );

                // Draw image - since transform maps srcTri to dstTri
                ctx.drawImage(
                    img,
                    0, 0, img.naturalWidth, img.naturalHeight,
                    0, 0, img.naturalWidth, img.naturalHeight
                );
                ctx.restore();
            }

            // Compute affine transform matrix from src to dest triangles
            function computeAffineTransform(src, dst) {
                // src and dst are arrays of 3 points: [[x0,y0],[x1,y1],[x2,y2]]

                const [x0, y0] = src[0];
                const [x1, y1] = src[1];
                const [x2, y2] = src[2];

                const [u0, v0] = dst[0];
                const [u1, v1] = dst[1];
                const [u2, v2] = dst[2];

                // Solve linear system for affine transform
                // x' = a*x + c*y + e
                // y' = b*x + d*y + f

                // Setup matrix:
                // |x0 y0 1 0  0  0| |a|   |u0|
                // |0  0  0 x0 y0 1| |b| = |v0|
                // |x1 y1 1 0  0  0|       |u1|
                // |0  0  0 x1 y1 1|       |v1|
                // |x2 y2 1 0  0  0|       |u2|
                // |0  0  0 x2 y2 1|       |v2|

                // 6 equations, 6 unknowns: a,b,c,d,e,f

                // Write system as Ax = b

                const A = [
                    [x0, y0, 1, 0, 0, 0],
                    [0, 0, 0, x0, y0, 1],
                    [x1, y1, 1, 0, 0, 0],
                    [0, 0, 0, x1, y1, 1],
                    [x2, y2, 1, 0, 0, 0],
                    [0, 0, 0, x2, y2, 1]
                ];

                const B = [u0, v0, u1, v1, u2, v2];

                // Solve with numeric.js
                const AT = numeric.transpose(A);
                const ATA = numeric.dot(AT, A);
                const ATB = numeric.dot(AT, B);
                const X = numeric.solve(ATA, ATB);

                return {
                    a: X[0], b: X[3],
                    c: X[1], d: X[4],
                    e: X[2], f: X[5]
                };
            }

            // Clear canvas first
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            // Draw two triangles
            drawTriangle(ctx, img, [srcCorners[0], srcCorners[1], srcCorners[3]], [tl, tr, bl]);
            drawTriangle(ctx, img, [srcCorners[1], srcCorners[2], srcCorners[3]], [tr, br, bl]);
        }

        // Download handler
        document.getElementById("downloadBtn").addEventListener("click", () => {
            if (!preview.src) {
                alert("Please upload an image first.");
                return;
            }

            const controls = {};
            CONTROL_CONFIG.forEach(c => {
                controls[c.id] = parseFloat(document.getElementById(c.id).value);
            });

            const img = preview;

            const w = img.naturalWidth;
            const h = img.naturalHeight;

            // Create offscreen canvas
            const canvas = document.createElement("canvas");
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext("2d");

            // Compute transformed corners
            const corners = getTransformedCorners(img, controls);

            // Draw warped image
            drawImageWarped(ctx, img, corners);

            // Download image
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "tilted_image.png";
                a.click();
                URL.revokeObjectURL(url);
            });
        });

        // Initialize controls with default transform
        updateTransform();

        // Template saving/loading

        function saveTemplate() {
            if (!preview.src) {
                alert("Upload an image before saving a template.");
                return;
            }
            const name = prompt("Enter a name for this template:");
            if (!name) return;

            const data = {};
            CONTROL_CONFIG.forEach(c => {
                data[c.id] = document.getElementById(c.id).value;
            });

            let templates = JSON.parse(localStorage.getItem("shakevision_templates") || "{}");
            templates[name] = data;
            localStorage.setItem("shakevision_templates", JSON.stringify(templates));
            alert(`Template "${name}" saved.`);
        }

        function loadTemplates() {
            const templates = JSON.parse(localStorage.getItem("shakevision_templates") || "{}");
            return templates;
        }

        function showTemplateModal() {
            const modal = document.getElementById("templateModal");
            const list = document.getElementById("templateList");
            list.innerHTML = "";

            const templates = loadTemplates();
            if (Object.keys(templates).length === 0) {
                list.innerHTML = "<p>No saved templates found.</p>";
            } else {
                Object.entries(templates).forEach(([name, data]) => {
                    const div = document.createElement("div");
                    div.className = "flex justify-between items-center bg-white/10 p-3 rounded-md cursor-pointer hover:bg-pink-500/30";
                    div.textContent = name;
                    div.onclick = () => {
                        Object.entries(data).forEach(([k, v]) => {
                            const slider = document.getElementById(k);
                            const val = document.getElementById(k + "-val");
                            if (slider && val) {
                                slider.value = v;
                                val.value = v;
                            }
                        });
                        updateTransform();
                        modal.classList.add("hidden");
                    };
                    list.appendChild(div);
                });
            }
            modal.classList.remove("hidden");
        }

        document.getElementById("saveTemplate").addEventListener("click", saveTemplate);
        document.getElementById("loadTemplate").addEventListener("click", showTemplateModal);
        document.getElementById("closeModal").addEventListener("click", () => {
            document.getElementById("templateModal").classList.add("hidden");
        });

    </script>

</body>

</html>